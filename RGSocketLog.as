/* *RGSocket.as * *  Developer: Micah Eckhardt *  Copyright (c) 2007 Machine Perception Laboratory, *  University of California San Diego, Micah Eckhardt *  *  Please read the disclaimer and notes about redistribution  *  at the end of this file. *//*import flash.errors.*;import flash.events.*;import flash.net.XMLSocket;import flash.utils.Timer;import flash.events.TimerEvent;import flash.events.Event;import flash.system.fscommand;import flash.display.InteractiveObject;import flash.events.*;import flash.display.Stage;import flash.display.StageDisplayState;import flash.media.Sound;*/public class classes.RGSocketLog extends XMLSocket{	private var registered:Boolean;	private var nodeName:String;	private var hostName:String;	private var registrationString:String;	private var portNumber:Number;	private var socket:XMLSocket;	private var onCloseGoToFrame:String;	private var connectionReady:Boolean;	private var currentPong:Number;	private var lastPong:Number;	private var intervalId:Number;	private var command:String;	public function RGSocket()	{		this.registered = false;		this.connectionReady = false;		this.onCloseGoToFrame = null;		this.nodeName = null;		this.hostName = null;		this.registrationString = null;		this.command = null;		this.portNumber = 0;		this.currentPong = 0;		this.lastPong = 0;		this.socket = new XMLSocket();		this.intervalId = setInterval(this, "ping", 10000, "PING");	}	public function connectSocketLog()	{		//trace("hostName and port" + hostName + " " + portNumber); 		connect(hostName,portNumber);		this.registered = true;	}	//override onData	public function onData(evt)	{		var dat:String = evt;		if (dat.length == 0)		{			return;		}		trace("received: " + dat);		if (dat.lastIndexOf("Controller:") > -1)		{			// Given rubios command 			var start:Number = dat.lastIndexOf("Controller:");			var end:Number = dat.length - 1;			this.command = dat.substring(start, end);		}		if (dat.lastIndexOf("Registration Successful") > -1)		{			this.registered = true;			//    trace("Registered :)");		}		//registration no longer fails  		//if(dat.lastIndexOf("RUBIOS Registration Failed" )> -1) {		//fscommand("quit","true");		//}		if ((dat.lastIndexOf("REMOVE") > -1 || dat.lastIndexOf("KILL") > -1) && dat.lastIndexOf(nodeName) > -1)		{			trace("line 54 RGSocket");			sendData(nodeName + " Received Kill Message. Disconnecting");			fscommand("quit", "true");		}		else if (dat.lastIndexOf("STATE") > -1 && dat.lastIndexOf("STATE:") < 0)		{			sendData("STATE: " + nodeName + ": Active: true");		}		else if (dat.lastIndexOf("PONG") > -1)		{			trace("got a pong");			this.lastPong = this.currentPong;			this.currentPong = getTimer();			if (currentPong - lastPong > 180000)			{				sendData(nodeName + " have not Received PONG for more than 3 minute. Disconnecting.");				fscommand("quit", "true");			}		}	}	public function isCommand(str:String):Boolean	{		var rtnVal:Boolean = true;		if (this.command.lastIndexOf(str) > -1)		{			rtnVal = true;		}		else		{			rtnVal = false;		}		return rtnVal;	}	public function setCommand(str:String)	{		this.command = str;	}	//override supper	public function onClose()	{		// We've been disconnected from RUBIOS, we need to close the shop		trace("mySocket.onClose");		this.registered = false;		gotoAndPlay(onCloseGoToFrame);		//fscommand("quit", "true");	}	public function onConnect(success:Boolean)	{		trace("attempting connection to server");		if (success)		{			trace("connected :)");			trace(registrationString);			this.connectionReady = true;			sendData(registrationString);		}		else		{			trace("no connection :(");			this.registered = false;			gotoAndPlay(onCloseGoToFrame);		}	}	function sendData(msg:String)	{		if (msg.length > 127)		{			var leftsubstr:String = msg.substr(0, 127 - 3) + "...";			var rightsubstr:String = msg.substr(127 - 3);			sendData(leftsubstr);			sendData(rightsubstr);		}		else		{			while (msg.length < 127)			{				msg += " ";			}			trace("sendData: [" + msg + "]");			if (connectionReady)			{				send(msg);			}		}	}	private function ping(msg:String):Void	{		sendData(msg);		if (this.currentPong - this.lastPong > 180000)		{			sendData(nodeName + " have not Received PONG for more than 3 minute. Disconnecting.");			fscommand("quit", "true");		}	}	//set methods	public function setHostName(host:String)	{		this.hostName = host;	}	public function setPortNumber(aPort:Number)	{		this.portNumber = aPort;	}	public function setRegistrationString(regStr:String)	{		this.registrationString = regStr;	}	public function setNodeName(name:String)	{		this.nodeName = name;	}	public function setCloseFrameName(frameName:String)	{		this.onCloseGoToFrame = frameName;	}	//access methods	public function getRegistered():Boolean	{		return this.registered;	}	public function getnodeName():String	{		return this.nodeName;	}	public function getHostName():String	{		return this.hostName;	}	public function getRegistrationString():String	{		return this.registrationString;	}	public function getPortNumber():Number	{		return this.portNumber;	}	public function getConnectionReady():Boolean	{		return this.connectionReady;	}	public function getCloseFrameName():String	{		return this.onCloseGoToFrame;	}}/* *  * Redistribution and use in source and binary forms, with or without modification,  * are permitted provided that the following conditions are met: *  *    1. Redistributions of source code must retain the above copyright notice, this  *     list of conditions and the following disclaimer. *    2. Redistributions in binary form must reproduce the above copyright notice, this *       list of conditions and the following disclaimer in the documentation and/or  *     other materials provided with the distribution. *    3. The name of the author may not be used to endorse or promote products derived *     from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FO * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIR * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CON * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *  */